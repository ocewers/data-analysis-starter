#!/usr/bin/env python
"""
Generate a data‑pipeline graph from Jupyter notebooks.

Features
--------
* Scans all notebooks under `notebooks/` for common file I/O patterns.
* Builds a directed NetworkX graph: files ⇄ notebooks.
* Emits the graph as Mermaid text which can be rendered in docs or previews.

Usage
-----
python pipeline_graph.py --root /path/to/project --out pipeline.mmd
"""

import argparse
import ast
import re
from collections import defaultdict
from pathlib import Path
from typing import Dict, Optional, Sequence, Set, Tuple

import nbformat
import networkx as nx

MERMAID_HEADER = """%% Autogenerated by pipeline_graph.py
graph LR
    classDef notebook fill:#87CEFA,stroke:#1f4f88,stroke-width:1px,color:#000;
    classDef file fill:#D3D3D3,stroke:#555,stroke-width:1px,color:#000;
"""

BASE_DIR_ALIASES = {
    "DATA_DIR": "data",
    "OUTPUT_DIR": "output",
    "TESTS_DIR": "tests",
    "NOTEBOOKS_DIR": "notebooks",
    "SRC_DIR": "src",
}

READ_METHODS = {"read_csv", "read_parquet", "read_json", "read_excel"}
WRITE_METHODS = {"to_csv", "to_parquet", "to_json", "to_excel"}
WRITE_PATH_KEYWORDS = ("path", "path_or_buf")

# ---------------------------------------------------------------------------
# Regex patterns for I/O – extend as needed
# ---------------------------------------------------------------------------

# READ_PATTERNS = [
#    r"read_(csv|parquet|json|excel)\(\s*['\"]([^'\"]+)['\"]",  # pd.read_xxx("file")
#    r"open\(\s*['\"]([^'\"]+)['\"]",  # open("file")
# ]
# WRITE_PATTERNS = [
#    r"to_parquet\(\s*['\"]([^'\"]+)['\"]",
#    r"to_csv\(\s*['\"]([^'\"]+)['\"]",
#    r"to_json\(\s*['\"]([^'\"]+)['\"]",
#    r"to_excel\(\s*['\"]([^'\"]+)['\"]",
# ]

READ_PATTERNS = [
    r"read_(?:csv|parquet|json|excel)\([^)]*?['\"]([^'\"]+\.(?:csv|parquet|json|xlsx?|xlsm))['\"][^)]*\)",
]

WRITE_PATTERNS = [
    r"to_(?:csv|parquet|json|excel)\([^)]*?['\"]([^'\"]+\.(?:csv|parquet|json|xlsx?|xlsm))['\"][^)]*\)",
]


# ---------------------------------------------------------------------------
# Helper functions
# ---------------------------------------------------------------------------
def extract_paths(cell_source: str, patterns) -> Set[str]:
    """Return a set of file paths matching the supplied regex patterns."""
    paths: Set[str] = set()
    for pat in patterns:
        for match in re.findall(pat, cell_source, flags=re.IGNORECASE | re.DOTALL):
            paths.add(match)
    return paths


def analyze_notebook(nb_path: Path) -> Tuple[Set[str], Set[str]]:
    """Return (inputs, outputs) discovered in a notebook."""
    nb = nbformat.read(nb_path, as_version=4)
    inputs, outputs = set(), set()
    var_sources: Dict[str, Set[str]] = defaultdict(set)

    for cell in nb.cells:
        if cell.cell_type != "code":
            continue
        src = cell.source
        inputs.update(extract_paths(src, READ_PATTERNS))
        outputs.update(extract_paths(src, WRITE_PATTERNS))

        try:
            tree = ast.parse(src)
        except SyntaxError:
            continue

        visitor = DependencyVisitor(var_sources, inputs, outputs)
        visitor.visit(tree)

    # print all inputs and outputs for debugging
    if inputs:
        print(f"Inputs in {nb_path.name}: {', '.join(inputs)}")
    if outputs:
        print(f"Outputs in {nb_path.name}: {', '.join(outputs)}")

    return inputs, outputs


def resolve_file_node(path_str: str, project_root: Path) -> str:
    """Return a stable node identifier including path context when available."""
    path = Path(path_str)

    if path.is_absolute():
        try:
            return str(path.relative_to(project_root))
        except ValueError:
            return str(path)

    if path.parent != Path('.'):
        return str(path)

    candidate = project_root / path
    if candidate.exists():
        return str(path)

    for subdir in ("data", "output", "tests/data", "notebooks", "src", "tests"):
        candidate = project_root / subdir / path
        if candidate.exists():
            return str(Path(subdir) / path)

    for match in project_root.rglob(path.name):
        try:
            return str(match.relative_to(project_root))
        except ValueError:
            return str(match)

    return str(path)


def build_graph(project_root: Path) -> nx.DiGraph:
    """Create a directed graph of notebooks and files."""
    notebooks_dir = project_root / "notebooks"
    graph = nx.DiGraph()

    for nb_path in notebooks_dir.rglob("*.ipynb"):
        inputs, outputs = analyze_notebook(nb_path)
        nb_node = f"{nb_path.relative_to(project_root)}"
        graph.add_node(nb_node, node_type="notebook", label=nb_node)

        for in_file in inputs:
            file_node = resolve_file_node(in_file, project_root)
            graph.add_node(file_node, node_type="file", label=file_node)
            graph.add_edge(file_node, nb_node)

        for out_file in outputs:
            file_node = resolve_file_node(out_file, project_root)
            graph.add_node(file_node, node_type="file", label=file_node)
            graph.add_edge(nb_node, file_node)

    return graph


# ---------------------------------------------------------------------------
def draw_graph_mermaid(graph: nx.DiGraph, out_path: Path) -> None:
    """Render graph as Mermaid text."""
    node_ids = {node: f"n{idx}" for idx, node in enumerate(sorted(graph.nodes()), start=1)}
    lines = [MERMAID_HEADER.rstrip()]

    for node, data in graph.nodes(data=True):
        label = data["label"].replace("\"", r"\"")
        lines.append(f'    {node_ids[node]}["{label}"]')

    for src, dst in graph.edges():
        lines.append(f"    {node_ids[src]} --> {node_ids[dst]}")

    notebook_nodes = [node_ids[n] for n, data in graph.nodes(data=True) if data["node_type"] == "notebook"]
    file_nodes = [node_ids[n] for n, data in graph.nodes(data=True) if data["node_type"] == "file"]

    if notebook_nodes:
        lines.append(f"    class {','.join(notebook_nodes)} notebook;")
    if file_nodes:
        lines.append(f"    class {','.join(file_nodes)} file;")

    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"✅ Mermaid graph written to: {out_path}")


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------
def main() -> None:
    parser = argparse.ArgumentParser(
        description="Generate pipeline graph from notebooks."
    )
    parser.add_argument(
        "--root",
        type=Path,
        default=Path("."),
        help="Project root containing data/, notebooks/ and output/ folders.",
    )
    parser.add_argument(
        "--out",
        type=Path,
        default=Path("pipeline.mmd"),
        help="Output Mermaid file (.md/.mmd).",
    )
    args = parser.parse_args()

    graph = build_graph(args.root)
    if not graph:
        print("⚠️  No notebook dependencies found.")
        return

    draw_graph_mermaid(graph, args.out)


class DependencyVisitor(ast.NodeVisitor):
    """Track glob-based file usage within a notebook cell."""

    def __init__(
        self,
        var_sources: Dict[str, Set[str]],
        inputs: Set[str],
        outputs: Set[str],
    ) -> None:
        self.var_sources = var_sources
        self.inputs = inputs
        self.outputs = outputs

    # ------------------------------------------------------------------
    # AST helpers
    # ------------------------------------------------------------------
    def visit_Assign(self, node: ast.Assign) -> None:  # type: ignore[override]
        sources = self._sources_from_value(node.value)
        if sources:
            for name in self._collect_target_names(node.targets):
                self.var_sources[name].update(sources)
        self.generic_visit(node)

    def visit_AnnAssign(self, node: ast.AnnAssign) -> None:  # type: ignore[override]
        targets = [node.target] if node.target is not None else []
        sources = self._sources_from_value(node.value) if node.value else set()
        if sources:
            for name in self._collect_target_names(targets):
                self.var_sources[name].update(sources)
        self.generic_visit(node)

    def visit_For(self, node: ast.For) -> None:  # type: ignore[override]
        sources = self._sources_from_iter(node.iter)
        if sources:
            for name in self._collect_name_targets(node.target):
                self.var_sources[name].update(sources)
        self.generic_visit(node)

    def visit_Call(self, node: ast.Call) -> None:  # type: ignore[override]
        attr = self._call_attr(node.func)
        if attr in READ_METHODS and node.args:
            sources = self._resolve_arg_sources(node.args[0])
            if sources:
                self.inputs.update(sources)
        elif attr in WRITE_METHODS:
            path_expr = self._extract_write_path(node)
            if path_expr:
                self.outputs.add(path_expr)
        self.generic_visit(node)

    # ------------------------------------------------------------------
    # Extraction helpers
    # ------------------------------------------------------------------
    def _sources_from_value(self, value: Optional[ast.AST]) -> Set[str]:
        if value is None:
            return set()

        if isinstance(value, ast.Call):
            glob_sources = self._extract_glob_sources(value)
            if glob_sources:
                return glob_sources

        if isinstance(value, ast.Name):
            return set(self.var_sources.get(value.id, set()))

        return set()

    def _sources_from_iter(self, node: ast.AST) -> Set[str]:
        if isinstance(node, ast.Name):
            return set(self.var_sources.get(node.id, set()))

        if isinstance(node, ast.Call):
            # list(DATA_DIR.glob(...)) style wrappers
            attr = self._call_attr(node.func)
            if attr == "list" and node.args:
                return self._sources_from_iter(node.args[0])
            return self._extract_glob_sources(node)

        return set()

    def _resolve_arg_sources(self, arg: ast.AST) -> Set[str]:
        if isinstance(arg, ast.Name):
            return set(self.var_sources.get(arg.id, set()))

        if isinstance(arg, ast.BinOp):
            path_str = self._eval_path_expr(arg)
            if path_str:
                return {path_str}

        if isinstance(arg, ast.Constant) and isinstance(arg.value, str):
            return {arg.value}

        return set()

    def _extract_write_path(self, node: ast.Call) -> Optional[str]:
        candidates: Sequence[ast.AST] = []
        if node.args:
            candidates = node.args
        else:
            keyword_args = [kw.value for kw in node.keywords if kw.arg in WRITE_PATH_KEYWORDS]
            candidates = keyword_args

        for value in candidates:
            path = self._eval_path_expr(value)
            if path:
                return path
            if isinstance(value, ast.Name) and value.id in self.var_sources:
                sources = self.var_sources[value.id]
                if sources:
                    return next(iter(sources))
            if isinstance(value, ast.Constant) and isinstance(value.value, str):
                return value.value
        return None

    def _extract_glob_sources(self, call: ast.Call) -> Set[str]:
        attr = self._call_attr(call.func)
        if attr != "glob" or not call.args:
            return set()

        pattern = self._literal_string(call.args[0])
        if not pattern:
            return set()

        base_path = self._eval_path_expr(getattr(call.func, "value", None))
        if base_path:
            return {str(Path(base_path) / pattern)}
        return {pattern}

    # ------------------------------------------------------------------
    # Utility helpers
    # ------------------------------------------------------------------
    def _collect_target_names(self, targets: Sequence[ast.AST]) -> Set[str]:
        names: Set[str] = set()
        for target in targets:
            names.update(self._collect_name_targets(target))
        return names

    def _collect_name_targets(self, target: ast.AST) -> Set[str]:
        if isinstance(target, ast.Name):
            return {target.id}
        if isinstance(target, (ast.Tuple, ast.List)):
            collected: Set[str] = set()
            for elt in target.elts:
                collected.update(self._collect_name_targets(elt))
            return collected
        return set()

    def _call_attr(self, func: ast.AST) -> Optional[str]:
        if isinstance(func, ast.Attribute):
            return func.attr
        if isinstance(func, ast.Name):
            return func.id
        return None

    def _literal_string(self, node: ast.AST) -> Optional[str]:
        if isinstance(node, ast.Constant) and isinstance(node.value, str):
            return node.value
        return None

    def _eval_path_expr(self, node: Optional[ast.AST]) -> Optional[str]:
        if node is None:
            return None
        if isinstance(node, ast.Constant) and isinstance(node.value, str):
            return node.value
        if isinstance(node, ast.Name):
            alias = BASE_DIR_ALIASES.get(node.id)
            if alias:
                return alias
            return None
        if isinstance(node, ast.BinOp) and isinstance(node.op, ast.Div):
            left = self._eval_path_expr(node.left)
            right = self._eval_path_expr(node.right)
            if left and right:
                return str(Path(left) / right)
            return left or right
        if isinstance(node, ast.Call):
            attr = self._call_attr(node.func)
            if attr == "joinpath" and node.args:
                base = self._eval_path_expr(getattr(node.func, "value", None))
                parts = [self._literal_string(arg) for arg in node.args]
                if base and all(part for part in parts):
                    path = Path(base)
                    for part in parts:
                        path /= str(part)
                    return str(path)
        if isinstance(node, ast.Attribute) and isinstance(node.value, ast.Name):
            alias = BASE_DIR_ALIASES.get(node.value.id)
            if alias:
                return str(Path(alias) / node.attr)
        return None


if __name__ == "__main__":
    main()
